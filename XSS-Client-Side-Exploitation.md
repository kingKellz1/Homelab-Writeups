# Lab 6: Cross-Site Scripting (XSS)

**Target:** DVWA Application (Port 80)
**IP Address:** 192.168.10.100
**Vulnerability Type:** Stored XSS (Client-Side)
**Tools:** Web Browser, Minimized JavaScript Payloads
**Security Level:** Low

---

## 1. Initial Reconnaissance & Input Filtering Bypass

The goal was to inject a malicious script that would be stored in the database and executed by any visitor (Stored XSS).

### A. Input Field Analysis
Initial testing revealed that the application employed **input-specific filtering**:
* The **Name** field rejected the `<script>` tag, indicating a filter was active on that input parameter.
* The **Message** field accepted the `<script>` tag (after troubleshooting network issues), confirming the filtering was incomplete.

### B. Length Restriction Bypass
The full, standard cookie-stealing payload was then rejected by the **Message** field due to a **length restriction** (likely a small database field size, e.g., VARCHAR(20)).

---

## 2. Exploitation: Minimal Payload Injection

To bypass the length restriction and achieve code execution, a **minimized, event-based payload** was used.

### A. Confirmed Vulnerability Payload
* **Goal:** Pop-up an alert box.
* **Payload Used:** `<img src=x onerror=alert('XSS Confirmed!')>`
* **Result:** Script executed successfully, confirming the vulnerability.

### B. Final Cookie Theft Payload
The final payload was constructed to steal the session cookie, using the same minimized structure.

* **Goal:** Display the victim's session cookie.
* **Final Payload:**
    ```html
    <img src=x onerror=alert(document.cookie)>
    ```

* **Impact:** This simple payload executed the JavaScript function `alert(document.cookie)`, exposing the victim's session ID (`PHPSESSID`). In a real-world scenario, the `alert()` function would be replaced with a script to quietly send the cookie data to an external attacker-controlled server (a "phishing" server).

---

## 3. Mitigation/Remediation

The XSS vulnerability occurred because user input was rendered directly in the HTML output without being treated as data.

* **Primary Fix:** Implement **Output Encoding**. All user-supplied data must be converted into a safe form (e.g., `<` becomes `&lt;`) before being rendered in the browser. This ensures the browser treats the input as harmless text, not as executable HTML tags.
* **Secondary Fix:** Implement **Input Validation and Sanitization**. Aggressively filter or strip known harmful tags (`<script>`, `onerror`, etc.) from *all* input fields, and enforce strict length limits to prevent buffer overflows and length-abuse attacks.
